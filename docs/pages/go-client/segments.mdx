# Segments

Segments track sub-operations within a transaction, helping you understand where time is spent during request processing or background task execution.

## Common Use Cases

- Database queries
- External API calls
- Cache operations
- File I/O
- Business logic steps

## Basic Usage

```go
import "github.com/tracewayapp/go-client/traceway"

func handler(c *gin.Context) {
    ctx := c.Request.Context()

    // Start a segment
    seg := traceway.StartSegment(ctx, "database.users.find")

    // Do the operation
    user, err := db.FindUser(userID)

    // End the segment (records duration)
    seg.End()

    if err != nil {
        c.Error(err)
        return
    }

    c.JSON(200, user)
}
```

## Naming Conventions

Use hierarchical, descriptive names for easy filtering and analysis:

```go
// Database operations
traceway.StartSegment(ctx, "db.users.find")
traceway.StartSegment(ctx, "db.orders.insert")
traceway.StartSegment(ctx, "db.products.update")

// External APIs
traceway.StartSegment(ctx, "api.stripe.charge")
traceway.StartSegment(ctx, "api.sendgrid.send")
traceway.StartSegment(ctx, "api.s3.upload")

// Cache operations
traceway.StartSegment(ctx, "cache.redis.get")
traceway.StartSegment(ctx, "cache.redis.set")

// Business logic
traceway.StartSegment(ctx, "logic.pricing.calculate")
traceway.StartSegment(ctx, "logic.validation.order")
```

### Naming Constants

For consistency across your codebase, define naming constants:

```go
const (
    SegmentDBQuery  = "db.%s.%s"     // db.users.find
    SegmentAPICall  = "api.%s.%s"    // api.stripe.charge
    SegmentCacheOp  = "cache.%s.%s"  // cache.redis.get
)

seg := traceway.StartSegment(ctx, fmt.Sprintf(SegmentDBQuery, "orders", "find"))
```

## Multiple Segments

Track multiple operations in sequence:

```go
func processOrder(ctx context.Context, orderID string) error {
    // Fetch order
    seg := traceway.StartSegment(ctx, "db.orders.find")
    order, err := db.GetOrder(orderID)
    seg.End()
    if err != nil {
        return err
    }

    // Validate inventory
    seg = traceway.StartSegment(ctx, "logic.inventory.check")
    available := checkInventory(order.Items)
    seg.End()
    if !available {
        return errors.New("items unavailable")
    }

    // Charge payment
    seg = traceway.StartSegment(ctx, "api.stripe.charge")
    err = stripe.Charge(order.PaymentMethod, order.Total)
    seg.End()
    if err != nil {
        return err
    }

    // Update order status
    seg = traceway.StartSegment(ctx, "db.orders.update")
    err = db.UpdateOrderStatus(orderID, "paid")
    seg.End()

    return err
}
```

## Nested Segments

Segments can be nested for hierarchical tracking:

```go
func handler(c *gin.Context) {
    ctx := c.Request.Context()

    // Parent segment
    seg := traceway.StartSegment(ctx, "process.checkout")

    // Child segments
    childSeg := traceway.StartSegment(ctx, "process.checkout.validate")
    validate(cart)
    childSeg.End()

    childSeg = traceway.StartSegment(ctx, "process.checkout.charge")
    charge(payment)
    childSeg.End()

    childSeg = traceway.StartSegment(ctx, "process.checkout.fulfill")
    fulfill(order)
    childSeg.End()

    seg.End()
}
```

## Segments in Background Tasks

Segments work with both HTTP transactions and background tasks:

```go
func generateReport(ctx context.Context) {
    traceway.MeasureTask("report.monthly", func(ctx context.Context) {
        // Track data fetching
        seg := traceway.StartSegment(ctx, "report.fetch_data")
        data := fetchReportData()
        seg.End()

        // Track processing
        seg = traceway.StartSegment(ctx, "report.process")
        result := processData(data)
        seg.End()

        // Track upload
        seg = traceway.StartSegment(ctx, "report.upload")
        uploadToS3(result)
        seg.End()
    })
}
```

## Segment Data

Each segment captures:

| Field | Description |
|-------|-------------|
| `id` | Unique segment identifier |
| `name` | Descriptive name you provide |
| `start_time` | When the segment started |
| `duration` | Time spent (calculated on `End()`) |

## Using Defer for Safety

Use defer to ensure segments end even when errors occur:

```go
func fetchData(ctx context.Context) (*Data, error) {
    seg := traceway.StartSegment(ctx, "api.external.fetch")
    defer seg.End()  // Ensures segment ends even on error

    resp, err := http.Get(url)
    if err != nil {
        return nil, err
    }
    return parseResponse(resp)
}
```

## Viewing Segments in Dashboard

In the dashboard:
1. Navigate to the **Endpoints** page
2. Click on an endpoint to see details
3. Individual transactions show their segments
4. Segments display as a timeline within the transaction

## Best Practices

### 1. Track Meaningful Operations

Track significant operations, not every function call:

```go
// Good - tracks significant operation
seg := traceway.StartSegment(ctx, "db.users.find")
user := db.Query("SELECT * FROM users WHERE id = ?", id)
seg.End()

// Too granular - avoid this
seg := traceway.StartSegment(ctx, "db.prepare")
stmt := db.Prepare(query)
seg.End()
seg = traceway.StartSegment(ctx, "db.execute")
result := stmt.Execute(id)
seg.End()
```

### 2. Always End Segments

Unended segments won't appear in the dashboard:

```go
// Use defer for operations that might error
seg := traceway.StartSegment(ctx, "risky.operation")
defer seg.End()

// Or explicitly end in all code paths
seg := traceway.StartSegment(ctx, "operation")
result, err := doWork()
seg.End()  // End before returning
if err != nil {
    return nil, err
}
return result, nil
```

### 3. Keep Names Consistent

Use the same naming pattern across your codebase for easy filtering:

```go
// Consistent: category.resource.action
"db.users.find"
"db.users.insert"
"db.orders.find"
"api.stripe.charge"
"cache.redis.get"
```

### 4. Don't Over-Segment

Balance detail with overhead:

```go
// Good - key operations tracked
seg := traceway.StartSegment(ctx, "db.users.find")
user := findUser(id)
seg.End()

seg = traceway.StartSegment(ctx, "api.payment.charge")
chargeUser(user, amount)
seg.End()

// Over-segmented - too much noise
seg := traceway.StartSegment(ctx, "validate.input")
validateInput(input)
seg.End()

seg = traceway.StartSegment(ctx, "parse.json")
data := parseJSON(input)
seg.End()

seg = traceway.StartSegment(ctx, "check.nil")
checkNotNil(data)
seg.End()
```
