# HTTP Middleware Configuration

## Middleware Options

| Option | Description | Default |
|--------|-------------|---------|
| `WithRepanic(bool)` | Re-panic after capturing, letting upstream recovery handle it | `true` |
| `WithIgnoredPaths(...string)` | Skip recording for specific URL paths | none |
| `WithFilter(func(*http.Request) bool)` | Custom filter function — return `false` to skip recording | none |
| `WithOnErrorRecording(RecordingFlag)` | What additional data to capture on errors | `0` (none) |

## Passthrough Core Options

These options are forwarded to the core `traceway` client:

| Option | Description | Default |
|--------|-------------|---------|
| `WithDebug(bool)` | Enable debug logging | `false` |
| `WithVersion(string)` | Application version shown in dashboard | `""` |
| `WithServerName(string)` | Server hostname identifier | Auto-detected |
| `WithSampleRate(float64)` | Percentage of normal traces to record (0.0–1.0) | `1.0` |
| `WithErrorSampleRate(float64)` | Percentage of error traces to record (0.0–1.0) | `1.0` |
| `WithCollectionInterval(time.Duration)` | How often batched data is sent | `5s` |
| `WithMaxCollectionFrames(int)` | Maximum frames to buffer | `12` |
| `WithUploadTimeout(time.Duration)` | HTTP upload timeout | `2s` |
| `WithMetricsInterval(time.Duration)` | System metrics collection interval | `30s` |

## Repanic Behavior

When `WithRepanic(true)` (default), the middleware re-panics after capturing the stack trace. This allows upstream recovery middleware to handle the panic as well.

When `WithRepanic(false)`, the middleware responds with HTTP 500 and does not re-panic.

## Path Filtering

### WithIgnoredPaths

Skip recording for specific paths:

```go
tracewayhttp.New(
    connectionString,
    tracewayhttp.WithIgnoredPaths("/health", "/ready", "/metrics"),
)
```

Ignored paths are still served — the request passes through to your handler, but no trace is recorded.

### WithFilter

For dynamic filtering logic, use `WithFilter`. Return `false` to skip recording:

```go
tracewayhttp.New(
    connectionString,
    tracewayhttp.WithFilter(func(r *http.Request) bool {
        // Skip internal service-to-service calls
        if r.Header.Get("X-Internal") == "true" {
            return false
        }
        // Skip static assets
        if strings.HasPrefix(r.URL.Path, "/static/") {
            return false
        }
        return true
    }),
)
```

When the filter returns `false`, the request is passed directly to your handler without any Traceway wrapping.

## Differences from Gin Middleware

The HTTP middleware does **not** have `WithRecordUnmatched` or `WithRecordStatic` options — these are Gin-specific because `net/http` has no built-in route registration to distinguish matched vs unmatched routes.

Instead, the HTTP middleware provides `WithFilter` for custom request filtering, which is not available in the Gin middleware.

## Complete Example

```go
package main

import (
    "net/http"
    "time"

    traceway "go.tracewayapp.com"
    tracewayhttp "go.tracewayapp.com/tracewayhttp"
)

func main() {
    traceway.ConfigureAttributes(func(s *traceway.Attributes) {
        s.SetTag("environment", "production")
        s.SetTag("service", "order-api")
    })

    mux := http.NewServeMux()
    mux.HandleFunc("/api/orders", handleOrders)

    handler := tracewayhttp.New(
        "your-token@http://localhost:8082/api/report",
        tracewayhttp.WithVersion("1.2.3"),
        tracewayhttp.WithServerName("api-server-01"),
        tracewayhttp.WithRepanic(true),
        tracewayhttp.WithIgnoredPaths("/health", "/ready"),
        tracewayhttp.WithFilter(func(r *http.Request) bool {
            return r.Header.Get("X-Internal") != "true"
        }),
        tracewayhttp.WithOnErrorRecording(
            tracewayhttp.RecordingUrl | tracewayhttp.RecordingQuery,
        ),
        tracewayhttp.WithCollectionInterval(5 * time.Second),
        tracewayhttp.WithMetricsInterval(30 * time.Second),
    )(mux)

    http.ListenAndServe(":8080", handler)
}
```
